<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Tehnical Documentation</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.css">
    <link rel="stylesheet" href="vendor/Grid.css">
    <link rel="stylesheet" type="text/css" media="screen" href="style.css" />
    <link href="https://fonts.googleapis.com/css?family=Lato:100,300,300i,400" rel="stylesheet">
   
</head>
<body>
    <div class="row">

    <div>
        <nav id="navbar">
            <header>
                <img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/73/Ruby_logo.svg/2000px-Ruby_logo.svg.png" alt="pic">
                Ruby documentation
            </header>
            <ul class="main-nav">
                <a href="#Ruby_is..." class="nav-link">
                    <li>Ruby is...</li>
                </a>
                <a href="#What_to_Expect:_Language_X_to_Ruby" class="nav-link">
                    <li>What to Expect: Language X to Ruby</li>
                </a>
                <a href="#Iteration" class="nav-link">
                    <li>Iteration</li>
                </a>
                <a href="#Everything_has_a_value" class="nav-link">
                    <li>Everything has a value</li>
                </a>
                <a href="#Symbols_are_not_lightweight_Strings" class="nav-link">
                    <li>Symbols are not lightweight Strings</li>
                </a>
                <a href="#Everything_is_an_Object" class="nav-link">
                    <li>Everything is an Object</li>
                </a>
                <a href="#Variable_Constants" class="nav-link">
                    <li>Variable Constants</li>
                </a>
                <a href="#The_universal_truth" class="nav-link">
                    <li>The universal truth</li>
                </a>
                <a href="#Naming_conventions" class="nav-link">
                    <li>Naming conventions</li>
                </a>
                <a href="#Keyword_arguments" class="nav-link">
                    <li>Keyword arguments</li>
                </a>
                <a href="#Access_modifiers_apply_until_the_end_of_scope" class="nav-link">
                    <li>Access modifiers apply until the end of scope</li>
                </a>
                <a href="#Method_access" class="nav-link">
                    <li>Method access</li>
                </a>
                <a href="#Classes_are_open" class="nav-link">
                    <li>Classes are open</li>
                </a>
                <a href="#Funny_method_names" class="nav-link">
                    <li>Funny method names</li>
                </a>
                <a href="#Singleton_methods" class="nav-link">
                    <li>Singleton methods</li>
                </a>
                <a href="#Missing_methods" class="nav-link">
                    <li>Missing methods</li>
                </a>
                <a href="#Message_passing,_not_function_calls" class="nav-link">
                    <li>Message passing, not function calls</li>
                </a>
                <a href="#Blocks_are_Objects,_they_just_don’t_know_it_yet" class="nav-link">
                    <li>Blocks are Objects, they just don’t know it yet</li>
                </a>
                <a href="#Operators_are_syntactic_sugar" class="nav-link">
                    <li>Operators are syntactic sugar</li>
                </a>
                <a href="#Finding_Out_More" class="nav-link">
                    <li>Finding Out More</li>
                </a>
            </ul>
        </nav>
    </div>
    
    
    <!-- ---- -->
    <div>

    
      <main id="main-doc">
        <!-- Section 1  -->
        
        <section class="main-section" id="Ruby_is...">
            
                <header>
                    Ruby is...
                </header>
          

             
                <p>A dynamic, open source programming language with a focus on simplicity and productivity. It has an elegant syntax
                    that
                    is natural to read and easy to write.</p>
                <article>
                    <code>
                        <span class="comment"># Output "I love Ruby"</span>
                        say = "I love Ruby"
                        puts say
                                        
                         <span class="comment"># Output "I *LOVE* RUBY"</span>                      
                        say['love'] = "*love*"
                         puts say.upcase
                                        
                        <span class="comment"># Output "I *love* Ruby"</span>
                        <span class="comment"># five times</span>             
                        5.times { puts say }
                    </code>
                    When you first look at some Ruby code, it will likely remind you of other programming languages you’ve used. This is on
                    purpose. Much of the syntax is familiar to users of Perl, Python, and Java (among other languages), so if you’ve used
                    those, learning Ruby will be a piece of cake.<br><br>
                    
                        This document contains two major sections. The first attempts to be a rapid-fire summary of what you can expect to see
                        when going from language X to Ruby. The second section tackles the major language features and how they might compare
                        to what you’re already familiar with.
                   
                </article>
              
                      
        </section>
        <!-- Section 2  -->
        <section class="main-section" id="What_to_Expect:_Language_X_to_Ruby">
            <header>
                What to Expect: Language X to Ruby
            </header>
                <ul>
                    <li><a href="https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-c-and-cpp/" target="_blank">To Ruby From C and C++</a></li>
                    <li><a href="https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-java/" target="_blank">To Ruby From Java</a></li>
                    <li><a href="https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-perl/" target="_blank">To Ruby From Perl</a></li>
                    <li><a href="https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-php/" target="_blank">To Ruby From PHP</a></li>
                    <li><a href="https://www.ruby-lang.org/en/documentation/ruby-from-other-languages/to-ruby-from-python/" target="_blank">To Ruby From Python</a></li>
                </ul>
            
        </section>

        <!-- Section 3  -->
        <section class="main-section" id="Iteration">
            <header>
                Iteration
            </header>
            <p>
                Two Ruby features that are a bit unlike what you may have seen before, and which take some getting used to, are
                “blocks” and iterators. Instead of looping over an index (like with C, C++, or pre-1.5 Java), or looping over a list
                (like Perl’s <code style="display:inline; padding: 0;">for (@a) {...}</code>, or Python’s <code style="display:inline; padding: 0;">for i in aList: ...</code>), with Ruby you’ll very often instead see
            </p>
            <code>
                some_list.each do |this_item|
                <span class="comment"># We're inside the block.</span>
                <span class="comment"> # deal with this_item.</span>
                end
            </code>
            <p>
                For more info on each (and its friends <code style="display:inline; padding: 0;">collect</code>, <code style="display:inline; padding: 0;">find</code>, <code style="display:inline; padding: 0;">inject</code>, <code style="display:inline; padding: 0;">sort</code>, etc.), see <code style="display:inline; padding: 0;">ri Enumerable</code> (and then <code style="display:inline; padding: 0;">ri
                Enumerable#some_method</code>).
            </p>
        </section>

        <!-- Section 4  -->
        <section class="main-section" id="Everything_has_a_value">
            <header>
                Everything has a value
            </header>
            <p>
                There’s no difference between an expression and a statement. Everything has a value, even if that value is <code style="display:inline; padding: 0;">nil</code>. This is
                possible:
            </p>
            <code>
                x = 10
                y = 11
                z = if x < y 
                    <span style="margin-left: 40px;">true</span> 
                    <span style="margin-left: 20px;">else</span>
                    <span style="margin-left: 40px;">false</span>
                    <span style="margin-left: 20px;">end</span>
                z <span class="comment"># => true</span>
            </code>
        </section>


        <!-- Section 5  -->
        <section class="main-section" id="Symbols_are_not_lightweight_Strings">
            <header>
                Symbols are not lightweight Strings
            </header>
            <p>
                Many Ruby newbies struggle with understanding what Symbols are, and what they can be used for.
            </p>
            <p>
                Symbols can best be described as identities. A symbol is all about <strong>who</strong> it is, not <strong>what</strong> it is. Fire up <code style="display:inline; padding: 0;">irb</code> and see the
                difference:
            </p>
            <code>
                irb(main):001:0> :george.object_id == :george.object_id
                => true
                irb(main):002:0> "george".object_id == "george".object_id
                => false
                irb(main):003:0>
            </code>
            <p>
                The <code style="display:inline; padding: 0;">object_id</code> methods returns the identity of an Object. If two objects have the same <code style="display:inline; padding: 0;">object_id</code>, they are the same
                (point to the same Object in memory).
            </p>
            <p>
                As you can see, once you have used a Symbol once, any Symbol with the same characters references the same Object in
                memory. For any given two Symbols that represent the same characters, <code style="display:inline; padding: 0;">object_id</code>s match.
            </p>
            <p>
                Now take a look at the String (“george”). The <code style="display:inline; padding: 0;">object_id</code>s don’t match. That means they’re referencing two different
                objects in memory. Whenever you use a new String, Ruby allocates memory for it.
            </p>
            <p>
                If you’re in doubt whether to use a Symbol or a String, consider what’s more important: the identity of an object (i.e.
                a Hash key), or the contents (in the example above, “george”).
            </p>
           
        </section>
        <!-- Section 6  -->
        <section class="main-section" id="Everything_is_an_Object">
            <header>
                Everything is an Object
            </header>
            <p>
                “Everything is an object” isn’t just hyperbole. Even classes and integers are objects, and you can do the same things
                with them as with any other object:
            </p>
            <code>
                <span class="comment"># This is the same as</span>
                <span class="comment"># class MyClass</span>
            <span class="comment"># attr_accessor :instance_var</span>
            <span class="comment"># end</span>
                MyClass = Class.new do
                    <span style="margin-left:30px;">attr_accessor :instance_var</span>
                end
            </code>
        </section>

        <!-- Section 7 class="main-section"  -->
        <section class="main-section" id="Variable_Constants">
            <header>
                Variable Constants
            </header>
            <p>
                Constants are not really constant. If you modify an already initialized constant, it will trigger a warning, but not
                halt your program. That isn’t to say you <strong>should</strong> redefine constants, though.
            </p>
        </section>

        <section class="main-section" id="Naming_conventions">
            <header>
                Naming conventions
            </header>
            <p>
                Ruby enforces some naming conventions. If an identifier starts with a capital letter, it is a constant. If it starts
                with a dollar sign (<code style="display:inline; padding: 0;">$</code>), it is a global variable. If it starts with <code style="display:inline; padding: 0;">@</code>, it is an instance variable. If it starts with <code style="display:inline; padding: 0;">@@</code>,
                it is a class variable.
            </p>
            <p>
                Method names, however, are allowed to start with capital letters. This can lead to confusion, as the example below
                shows:
            </p>
            <code>
                Constant = 10
                def Constant
                <span style="margin-left: 30px;">11</span>
                end
            </code>
            <p>
                Now <code style="display:inline; padding: 0;">Constant</code> is 10, but <code style="display:inline; padding: 0;">Constant()</code> is 11.
            </p>
        </section>

        <section class="main-section" id="Keyword_arguments">
            <header>Keyword arguments</header>
            <p>
                Like in Python, since Ruby 2.0 methods can be defined using keyword arguments:
            </p>
            <code>
                def deliver(from: "A", to: nil, via: "mail")
                <span style="margin-left:20px;">"Sending from #{from} to #{to} via #{via}."</span>
                end
                
                deliver(to: "B")
                <span class="comment"># => "Sending from A to B via mail."</span>
                deliver(via: "Pony Express", from: "B", to: "A")
                <span class="comment"># => "Sending from B to A via Pony Express."</span>
            </code>
        </section>

        <section class="main-section" id="The_universal_truth">
            <header>
                The universal truth
            </header>
            <p>
                In Ruby, everything except <code style="display:inline; padding: 0;">nil</code> and <code style="display:inline; padding: 0;">false</code> is considered true. In C, Python and many other languages, 0 and possibly
                other values, such as empty lists, are considered false. Take a look at the following Python code (the example applies
                to other languages, too):
            </p>
            <code>
                <span class="comment"># in Python</span>
                if 0:
                print("0 is true")
                else:
                print("0 is false")
            </code>
            <p>
                This will print “0 is false”. The equivalent Ruby:
            </p>
            <code>
                <span class="comment"># in Ruby</span>
                if 0
                <span style="margin-left:20px;">puts "0 is true"</span>
                else
                <span style="margin-left:20px;">puts "0 is false"</span>
                end
            </code>
            <p>
                Prints “0 is true”.
            </p>
        </section>

        <section class="main-section" id="Access_modifiers_apply_until_the_end_of_scope">
            <header>
                Access modifiers apply until the end of scope
            </header>
            <p>
                In the following Ruby code,
            </p>
            <code>
                class MyClass
                <span style="margin-left:20px;">private</span>
                <span style="margin-left:20px;">def a_method; true; end</span>
                <span style="margin-left:20px;">def another_method; false; end</span>
                end
            </code>
            <p>
                You might expect <code style="display:inline; padding: 0;">another_method</code> to be public. Not so. The <code style="display:inline; padding: 0;">private</code> access modifier continues until the end of the scope,
                or until another access modifier pops up, whichever comes first. By default, methods are public:
            </p>
            <code>
                class MyClass
                <span class="comment"># Now a_method is public</span>
            <span style="margin-left:20px;">def a_method; true; end</span>
                
                <span style="margin-left:20px;"></span>private</span>
                
                <span class="comment"># another_method is private</span>
                <span style="margin-left:20px;"></span>def another_method; false; end</span>
                end
            </code>
            <p>
                <code style="display:inline; padding: 0;">public</code>,<code style="display:inline; padding: 0;">private</code>  and <code style="display:inline; padding: 0;">protected</code> are really methods, so they can take parameters. If you pass a Symbol to one of them,
                that method’s visibility is altered.
            </p>
        </section>

        <section class="main-section" id="Method_access">
            <header>
                Method access
            </header>
            <p>
                In Java, <code style="display:inline; padding: 0;">public</code> means a method is accessible by anyone. <code style="display:inline; padding: 0;">protected</code> means the class’s instances, instances of descendant
                classes, and instances of classes in the same package can access it, but not anyone else, and <code style="display:inline; padding: 0;">private</code> means nobody
                besides the class’s instances can access the method.
            </p>
            <p>
                Ruby differs slightly. <code style="display:inline; padding: 0;">public</code> is, naturally, public. <code style="display:inline; padding: 0;">private</code> means the method(s) are accessible only when they can be
                called without an explicit receiver. Only <code style="display:inline; padding: 0;">self</code> is allowed to be the receiver of a private method call.
            </p>
            <p>
                <code style="display:inline; padding: 0;">protected</code> is the one to be on the lookout for. A protected method can be called from a class or descendant class
                instances, but also with another instance as its receiver. Here is an example (adapted from The Ruby Language FAQ):
            </p>
            <code>
                class Test
                <span class="comment"># public by default</span>
                def identifier
                99
                end
                
                def ==(other)
                identifier == other.identifier
                end
                end
                
                t1 = Test.new <span class="comment"># => #Test:0x34ab50</span>
                    t2 = Test.new <span class="comment"># => #Test:0x342784</span>
                        t1 == t2 <span class="comment"># => true</span>
                
                        <span class="comment"># now make `identifier' protected; it still works</span>
                        <span class="comment"># because protected allows `other' as receiver</span>
                
                        class Test
                        protected :identifier
                        end
                
                        t1 == t2 <span class="comment"># => true</span>
                
                        <span class="comment"># now make `identifier' private</span>
                
                        class Test
                        private :identifier
                        end
                
                        t1 == t2
                    <span class="comment"># NoMethodError: private method `identifier' called for #<Test:0x342784></span>
            </code>
        </section>

        <section class="main-section" id="Classes_are_open">
            <header>
                Classes are open
            </header>
            <p>
                Ruby classes are open. You can open them up, add to them, and change them at any time. Even core classes, like <code style="display:inline; padding: 0;">Fixnum</code>
                or even <code style="display:inline; padding: 0;">Object</code>, the parent of all objects. Ruby on Rails defines a bunch of methods for dealing with time on <code style="display:inline; padding: 0;">Fixnum</code>.
                Watch:
            </p>
            <code>
                class Fixnum
                def hours
                <span style="margin-left:20px;">self * 3600 </span><span class="comment"># number of seconds in an hour</span>
                <span style="margin-left:20px;">end</span>
                <span style="margin-left:20px;">alias hour hours</span>
                end
                
                <span class="comment"># 14 hours from 00:00 January 1st</span>
                <span class="comment"># (aka when you finally wake up ;)</span>
                Time.mktime(2006, 01, 01) + 14.hours <span class="comment"># => Sun Jan 01 14:00:00</span>
            </code>
        </section>

        <section class="main-section" id="Funny_method_names">
            <header>
                Funny method names
            </header>
            <p>
                In Ruby, methods are allowed to end with question marks or exclamation marks. By convention, methods that answer
                questions end in question marks (e.g. <code style="display:inline; padding: 0;">Array#empty?</code>, which returns <code style="display:inline; padding: 0;">true</code> if the receiver is empty). Potentially
                “dangerous” methods by convention end with exclamation marks (e.g. methods that modify <code style="display:inline; padding: 0;">self</code> or the arguments, <code style="display:inline; padding: 0;">exit!</code>,
                etc.). Not all methods that change their arguments end with exclamation marks, though. <code style="display:inline; padding: 0;">Array#replace</code> replaces the
                contents of an array with the contents of another array. It doesn’t make much sense to have a method like that 
                <strong>doesn’t</strong>modify self.
            </p>
        </section>

        <section class="main-section" id="Singleton_methods">
            <header>
                Singleton methods
            </header>
            <p>
                Singleton methods are per-object methods. They are only available on the Object you defined it on.
            </p>
            <code>
                class Car
                <span style="margin-left:20px;">def inspect</span>
                <span style="margin-left:40px;">"Cheap car"</span>
                <span style="margin-left:20px;">end</span>
                end
                
                porsche = Car.new
                porsche.inspect <span class="comment"># => Cheap car</span>
                def porsche.inspect
                <span style="margin-left:20px;">"Expensive car"</span>
                end
                
                porsche.inspect <span class="comment"># => Expensive car</span>
                
                <span class="comment"># Other objects are not affected</span>
                other_car = Car.new
                other_car.inspect <span class="comment"># => Cheap car</span>
            </code>
        </section>

        <section class="main-section" id="Missing_methods">
            <header>
                Missing methods
            </header>
            <p>
                Ruby doesn’t give up if it can’t find a method that responds to a particular message. It calls the <code style="display:inline; padding: 0;">method_missing</code>
                method with the name of the method it couldn’t find and the arguments. By default, <code style="display:inline; padding: 0;">method_missing</code> raises a NameError
                exception, but you can redefine it to better fit your application, and many libraries do. Here is an example:
            </p>
            <code>
                <span class="comment"># id is the name of the method called, the * syntax collects</span>
                <span class="comment"># all the arguments in an array named 'arguments'</span>
                def method_missing(id, *arguments)
                <span style="margin-left:20px;">puts "Method #{id} was called, but not found. It has " +</span>
                <span style="margin-left:60px;">"these arguments: #{arguments.join(", ")}"</span>
                end
                
                __ :a, :b, 10
            <span class="comment"># => Method __ was called, but not found. It has these</span>
                <span class="comment"># arguments: a, b, 10</span>
            </code>
            <p>
                The code above just prints the details of the call, but you are free to handle the message in any way that is
                appropriate.
            </p>
        </section>

            <section class="main-section" id="Message_passing,_not_function_calls">
                <header>
                Message passing, not function calls
            </header>
            <p>
                A method call is really a <strong>message</strong> to another object:
            </p>
            <code>
                <span class="comment"># This</span>
                1 + 2
                <span class="comment"># Is the same as this ...</span>
                1.+(2)
                <span class="comment"># Which is the same as this:</span>
                1.send "+", 2
            </code>
        </section>

        <section class="main-section" id="Blocks_are_Objects,_they_just_don’t_know_it_yet">
            <header>
                Blocks are Objects, they just don’t know it yet
            </header>
            <p>
                Blocks (closures, really) are heavily used by the standard library. To call a block, you can either use <code style="display:inline; padding: 0;">yield</code>, or make
                it a <code style="display:inline; padding: 0;">Proc</code> by appending a special argument to the argument list, like so:
            </p>
            <code>
                def block(&the_block)
                <span class="comment"># Inside here, the_block is the block passed to the method</span>
                <span style="margin-left:20px;">the_block </span><span class="comment"># return the block</span>
                end
                adder = block { |a, b| a + b }
                <span class="comment"># adder is now a Proc object</span>
                adder.class <span class="comment"># => Proc</span>
            </code>
            <p>
                You can create blocks outside of method calls, too, by calling <code style="display:inline; padding: 0;">Proc.new</code> with a block or calling the <code style="display:inline; padding: 0;">lambda</code> method.
            </p>
            <p>
                Similarly, methods are also Objects in the making:
            </p>
            <code>
                method(:puts).call "puts is an object!"
                <span class="comment"># => puts is an object!</span>
            </code>
        </section>

        <section class="main-section" id="Operators_are_syntactic_sugar">
            <header>
            Operators are syntactic sugar
            </header>
            <p>
                Most operators in Ruby are just syntactic sugar (with some precedence rules) for method calls. You can, for example,
                override Fixnum’s <code style="display:inline; padding: 0;">+</code> method:
            </p>
            <code>
                class Fixnum
                <span class="comment"># You can, but please don't do this</span>
                <span style="margin-left:20px;">def +(other)</span>
                    <span style="margin-left:40px;">self - other</span>
                <span style="margin-left:20px;">end</span>
                end
            </code>
            <p>
                You don’t need C++’s <code style="display:inline; padding: 0;">operator+</code>, etc.
            </p>
            <p>
                You can even have array-style access if you define the <code style="display:inline; padding: 0;">[]</code> and <code style="display:inline; padding: 0;">[]=</code> methods. To define the unary + and - (think +1 and
                -2), you must define the <code style="display:inline; padding: 0;">+@</code> and <code style="display:inline; padding: 0;">-@</code> methods, respectively. The operators below are <strong>not</strong> syntactic sugar, though. They are
                not methods, and cannot be redefined:
            </p>
            <code>
                =, .., ..., not, &&, and, ||, or, ::
            </code>
            <p>
                In addition, <code style="display:inline; padding: 0;">+=</code>, <code style="display:inline; padding: 0;">*=</code> etc. are just abbreviations for <code style="display:inline; padding: 0;">var = var + other_var</code>, <code style="display:inline; padding: 0;">var = var * other_var</code>, etc. and therefore
                cannot be redefined.
            </p>
        </section>

        <section class="main-section" id="Finding_Out_More">
            <header>
                Finding Out More
            </header>
            <p>
                When you are ready for more Ruby knowledge, see our <a href="https://www.ruby-lang.org/en/documentation/">Documentation</a> section.
            </p>
        </section>
      </main>  
    </div>
    </div>
</body>
</html>

<!--<span class="comment"># => "Sending from A to B via mail."</span>  -->
<!--<code style="display:inline; padding: 0;">Constant</code>  -->
<!-- <span style="margin-left:20px;"></span> -->